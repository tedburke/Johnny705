///////////////////////////////////
////// DO NOT EDIT THIS FILE //////
///////////////////////////////////

//
// Johnny705 robot simulator for TU705 Engineering Computing 2.1
// Written by Ted Burke - last updated 17-Oct-2021
//

#if defined(UNICODE) && !defined(_UNICODE)
    #define _UNICODE
#elif defined(_UNICODE) && !defined(UNICODE)
    #define UNICODE
#endif

// Note: To avoid the need for #include directives in robot.cpp,
// the arduino.h header file has been included using a compiler
// command line switch, which applies is equivalent to #including
// it at the first line of every cpp file in the project.
// To avoid a clash between the INPUT defined in arduino.h and
// the INPUT defined in windows.h, we need to undefine the arduino.h
// one here before #including windows.h.
#undef INPUT

#include <tchar.h>
#include <windows.h>
#include <gdiplus.h>
#include <iostream>
#include <thread>
#include <mutex>

// Include the player's "Arduino" code
#include "arduino.h"

// Global variables
Gdiplus::Image* pRobotImage = NULL;
Gdiplus::Image* pGroundImage = NULL;
int gw, gh, rw, rh;
int rx, ry, ra;

double g_start_x, g_start_y, g_start_angle;
DWORD g_start_time = 0, g_timer_time = 0;

HDC hdcMem = NULL;
HBITMAP hbmMem = NULL;

// Game functions
void update();
void draw(HWND);

// Set up a mutex protected flag to let world thread
// signal to main windows thread that redrawing is
// required due to world updates.
std::mutex updateFlagMutex;

bool updateFlag = false;

bool getUpdateFlag()
{
    bool retval;

    updateFlagMutex.lock();
    retval = updateFlag;
    updateFlagMutex.unlock();
    return retval;
}

void setUpdateFlag()
{
    updateFlagMutex.lock();
    updateFlag = 1;
    updateFlagMutex.unlock();
}

// Declare windows procedure and window class name
LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);
TCHAR szClassName[ ] = _T("CodeBlocksWindowsApp");

// Function prototype for world thread function
void world_thread_function();

void resetRobot()
{
    // Reset position
    g_robot.x = g_start_x;
    g_robot.y = g_start_y;
    g_robot.angle = g_start_angle;

    // Reset clock
    g_start_time = GetTickCount();
    g_timer_time = g_start_time;
}

void findStartPosition()
{
    Gdiplus::Bitmap groundBitmap (L"ground.png");
    int x, y;
    int r, g, b;
    Gdiplus::Color c;
    long blue_x=0, blue_y=0, blue_count=0;
    long cyan_x=0, cyan_y=0, cyan_count=0;
    for (y=0 ; y<gh ; ++y)
    {
        for (x=0 ; x<gw ; ++x)
        {
            groundBitmap.GetPixel(x, gh-1-y, &c);
            r = c.GetRed();
            g = c.GetGreen();
            b = c.GetBlue();

            if (r==0 && g==0 && b==255)
            {
                // Blue pixel
                blue_x += x;
                blue_y += y;
                blue_count++;
            }
            if (r==0 && g==255 && b==255)
            {
                // Cyan pixel
                cyan_x += x;
                cyan_y += y;
                cyan_count++;
            }
        }
    }
    blue_x /= (double)blue_count;
    blue_y /= (double)blue_count;
    cyan_x /= (double)cyan_count;
    cyan_y /= (double)cyan_count;

    g_start_x = (blue_x + cyan_x) / 2;
    g_start_y = (blue_y + cyan_y) / 2;
    g_start_angle = atan2(cyan_y - blue_y, cyan_x - blue_x) - M_PI/2.0;
}

int WINAPI WinMain (HINSTANCE hThisInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpszArgument,
                     int nCmdShow)
{
    HWND hwnd;               // This is the handle for our window
    MSG msg;                 // Here messages to the application are saved
    WNDCLASSEX wincl;        // Data structure for the windowclass

    printf("Johnny705 robot simulator for TU705 Engineering Computing 2.1\n");
    printf("Written by Ted Burke - last updated 17-Oct-2021\n\n");

    // Start Gdiplus
    Gdiplus::GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR gdiplusToken;
    Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    // Load the image
    pRobotImage = Gdiplus::Image::FromFile(L"robot.png");
    pGroundImage = Gdiplus::Image::FromFile(L"ground.png");
    if (pRobotImage == NULL)
    {
        MessageBox(NULL, "Error loading robot image", "Error", MB_OK);
        return 1;
    }
    if (pGroundImage == NULL)
    {
        MessageBox(NULL, "Error loading ground image", "Error", MB_OK);
        return 2;
    }

    g_robot.w = pRobotImage->GetWidth();
    g_robot.h = pRobotImage->GetHeight();
    gw = pGroundImage->GetWidth();
    gh = pGroundImage->GetHeight();

    g_start_x = gw/2;
    g_start_y = gh/2;
    g_start_angle = 0;

    // Find start position
    findStartPosition();

    resetRobot();

    printf("Robot image size: %d x %d\n", rw, rh);
    printf("Ground image size: %d x %d\n\n", gw, gh);

    // Window structure
    wincl.hInstance = hThisInstance;
    wincl.lpszClassName = szClassName;
    wincl.lpfnWndProc = WindowProcedure;              // Windows calls this function
    wincl.style = CS_DBLCLKS;                         // Catch double-clicks
    wincl.cbSize = sizeof (WNDCLASSEX);
    wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);   // Default icon
    wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); // Default icon
    wincl.hCursor = LoadCursor (NULL, IDC_ARROW);     // Default mouse pointer
    wincl.lpszMenuName = NULL;                        // No menu
    wincl.cbClsExtra = 0;                             // No extra bytes after window class structure
    wincl.cbWndExtra = 0;                             // No extra bytes after window instance
    wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;  // Default background colour

    // Register the window class
    if (!RegisterClassEx (&wincl)) return 0;

    // Calculate required window size to provide desired client area
    RECT rect; rect.top = 0; rect.left = 0; rect.right = gw; rect.bottom = gh;
    AdjustWindowRectEx(&rect, WS_OVERLAPPEDWINDOW, FALSE, 0);

    std::cerr << "adjusted windows size: " << rect.right - rect.left << " x " << rect.bottom - rect.top << std::endl;

    // Now that the class is registered, create the program
    hwnd = CreateWindowEx (
           0,                      // extended possibilites for variation
           szClassName,            // class name
           _T("Johnny705"),        // title text
           WS_OVERLAPPEDWINDOW,    // default window
           CW_USEDEFAULT,          // default x position of window
           CW_USEDEFAULT,          // default y position of window
           rect.right - rect.left, // window width
           rect.bottom - rect.top, // window height
           HWND_DESKTOP,           // indow is a child-window to desktop
           NULL,                   // no menu
           hThisInstance,          // program instance handler
           NULL                    // no window creation data
           );

    // Make the window visible on the screen
    ShowWindow (hwnd, nCmdShow);

    // Set up memory DC for double buffered drawing to screen
    PAINTSTRUCT ps;
    HDC hdc;
    hdc = BeginPaint(hwnd, &ps);
    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc, gw, gh);
    SelectObject(hdcMem, hbmMem);
    EndPaint(hwnd, &ps);

    // Launch other threads
    g_running = true;
    std::thread robot_thread(robot_thread_function);
    std::thread world_thread(world_thread_function);

    // Message loop with game updating
    while(1)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) == 0)
        {
            // There are no messages to be processed so update game
            if (getUpdateFlag()) InvalidateRect(hwnd, NULL, FALSE);
        }
        else
        {
            // There is a message to be processed
            if (GetMessage(&msg, NULL, 0, 0) == 0) break;
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Stop other threads
    g_running = false;
    world_thread.join();
    robot_thread.join();

    // Gdiplus clean up
    delete pRobotImage;
    delete pGroundImage;
    Gdiplus::GdiplusShutdown(gdiplusToken);

    DeleteDC(hdcMem);
    DeleteObject(hbmMem);

    // The program return-value is 0 - The value that PostQuitMessage() gave
    return msg.wParam;
}

LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_PAINT:
            draw(hwnd);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        case WM_KEYDOWN:
            if (wParam == 'Q' || wParam == VK_ESCAPE) PostQuitMessage(0); // exit
            if (wParam == VK_SPACE) resetRobot(); // Reset clock and robot position
            break;
        default:
            return DefWindowProc (hwnd, message, wParam, lParam);
    }

    return 0;
}

void world_thread_function()
{
    DWORD ticks_at_last_update = 0;
    DWORD ticks_now, elapsed_ticks;

    // Load ground PNG into a bitmap object so that the
    // "sensors" can read the pixel colours
    Gdiplus::Bitmap groundBitmap (L"ground.png");

    while(g_running)
    {
        // Relinquish control for a few ms to allow other threads to run.
        // Not really sure if this is useful or not!
        std::this_thread::sleep_for(std::chrono::milliseconds(1));

        // Find elapsed time in ms since last update
        ticks_now = GetTickCount();
        if (ticks_at_last_update == 0) elapsed_ticks = 0;
        else elapsed_ticks = ticks_now - ticks_at_last_update;
        ticks_at_last_update = ticks_now;

        int direction;
        double dL, dR; // left and right wheel distance
        double da;     // angle change
        double rc;     // turning radius (centre point of robot)
        double px, py, qx, qy; // unit vectors from robot's perspective

        if (g_robot.Dx[g_robot.LMF] == g_robot.Dx[g_robot.LMR]) direction = 0;
        else direction = g_robot.Dx[g_robot.LMF] > g_robot.Dx[g_robot.LMR] ? 1 : -1;
        dL = direction * g_robot.speedLeft * g_robot.maxSpeed * elapsed_ticks / 1000.0;

        if (g_robot.Dx[g_robot.RMF] == g_robot.Dx[g_robot.RMR]) direction = 0;
        else direction = g_robot.Dx[g_robot.RMF] > g_robot.Dx[g_robot.RMR] ? 1 : -1;
        dR = direction * g_robot.speedRight * g_robot.maxSpeed * elapsed_ticks / 1000.0;

        da = (dR - dL)/g_robot.w;

        px = cos(g_robot.angle);
        py = sin(g_robot.angle);
        qx = -sin(g_robot.angle);
        qy = cos(g_robot.angle);

        if (dL != dR)
        {
            // motors are moving at different speeds
            // so robot is turning as it moves
			rc = g_robot.w * 0.5 * ((dR+dL)/(dR-dL));

            if (dL + dR > 0)
            {
                g_robot.x += rc*(px*(1-cos(da)) + qx*sin(da));
                g_robot.y += rc*(py*(1-cos(da)) + qy*sin(da));
            }
            else
            {
                g_robot.x += rc*(px*(1-cos(da)) + qx*sin(da));
                g_robot.y += rc*(py*(1-cos(da)) + qy*sin(da));
            }
        }
        else
        {
            // motors are moving at the same speed and
            // in the same direction, so drive straight
            g_robot.x += dL*(qx);
            g_robot.y += dL*(qy);
        }

        // update robot angle
        g_robot.angle += da;

        // update sensor values
        px = cos(g_robot.angle);
        py = sin(g_robot.angle);
        qx = -sin(g_robot.angle);
        qy = cos(g_robot.angle);
        int fls_x, fls_y, frs_x, frs_y, bls_x, bls_y, brs_x, brs_y;
        fls_x = g_robot.x + (g_robot.h/2.0)*qx - (g_robot.w/2.0)*px;
        fls_y = g_robot.y + (g_robot.h/2.0)*qy - (g_robot.w/2.0)*py;
        frs_x = g_robot.x + (g_robot.h/2.0)*qx + (g_robot.w/2.0)*px;
        frs_y = g_robot.y + (g_robot.h/2.0)*qy + (g_robot.w/2.0)*py;
        bls_x = g_robot.x - (g_robot.h/2.0)*qx - (g_robot.w/2.0)*px;
        bls_y = g_robot.y - (g_robot.h/2.0)*qy - (g_robot.w/2.0)*py;
        brs_x = g_robot.x - (g_robot.h/2.0)*qx + (g_robot.w/2.0)*px;
        brs_y = g_robot.y - (g_robot.h/2.0)*qy + (g_robot.w/2.0)*py;

        Gdiplus::Color pxFLS, pxFRS, pxBLS, pxBRS;

        groundBitmap.GetPixel(fls_x, gh - fls_y, &pxFLS);
        g_robot.Ax[g_robot.FLS] = 1023.0/(3*255.0) * ((double)pxFLS.GetRed()
                                            + (double)pxFLS.GetGreen()
                                            + (double)pxFLS.GetBlue());
        groundBitmap.GetPixel(frs_x, gh - frs_y, &pxFRS);
        g_robot.Ax[g_robot.FRS] = 1023.0/(3*255.0) * ((double)pxFRS.GetRed()
                                            + (double)pxFRS.GetGreen()
                                            + (double)pxFRS.GetBlue());
        groundBitmap.GetPixel(bls_x, gh - bls_y, &pxBLS);
        g_robot.Ax[g_robot.BLS] = 1023.0/(3*255.0) * ((double)pxBLS.GetRed()
                                            + (double)pxBLS.GetGreen()
                                            + (double)pxBLS.GetBlue());
        groundBitmap.GetPixel(brs_x, gh - brs_y, &pxBRS);
        g_robot.Ax[g_robot.BRS] = 1023.0/(3*255.0) * ((double)pxBRS.GetRed()
                                            + (double)pxBRS.GetGreen()
                                            + (double)pxBRS.GetBlue());

        if (g_robot.Ax[g_robot.FLS] < 1000 || g_robot.Ax[g_robot.FRS] < 1000
            || g_robot.Ax[g_robot.BLS] < 1000 || g_robot.Ax[g_robot.BRS] < 1000)
        {
            // Robot not on parking space, so update timer clock
            g_timer_time = ticks_now;
        }

        // Let main windows thread know that it's time to redraw
        setUpdateFlag();
    }
}

void draw(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC hdc;

    // Draw the ground and the robot
    Gdiplus::Graphics graphics(hdcMem);
    graphics.DrawImage(pGroundImage, 0, 0, gw, gh);
    graphics.TranslateTransform(g_robot.x, gh - g_robot.y);
    graphics.RotateTransform(-180.0*g_robot.angle/M_PI);
    Gdiplus::REAL x, y, w, h;
    w = pRobotImage->GetWidth();
    h = pRobotImage->GetHeight();
    x = -w / 2.0;
    y = -h / 2.0;
    graphics.DrawImage(pRobotImage, x, y, w, h);
    graphics.ResetTransform();

    // Draw timer clock
    wchar_t timer_string[255];
    double timer = 0.001 * (g_timer_time - g_start_time);
    swprintf_s(timer_string, L"%.3lf", timer);
    Gdiplus::Font font(L"Arial", 32);
    Gdiplus::PointF origin(0.0f, 0.0f);
    DWORD ticks_now = GetTickCount();
    int r, g, b;
    if (ticks_now - g_timer_time > 100) {r=255; g=255; b=255;}
    else {r=0; g=0 ; b=0;}
    Gdiplus::SolidBrush brush(Gdiplus::Color(255, r, g, b));
    graphics.DrawString(timer_string, wcslen(timer_string), &font, origin, &brush);

    // Copy back buffer to screen
    hdc = BeginPaint(hwnd, &ps);
    BitBlt(hdc, 0, 0, gw, gh, hdcMem, 0, 0, SRCCOPY);
    EndPaint(hwnd, &ps);
}
